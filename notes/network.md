# 感谢
- [CyC2018/CS-Notes](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)

- [huihut/interview](https://github.com/huihut/interview)

- [linw7/Skill-Tree](https://github.com/linw7/Skill-Tree/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)

---

# 目录

#### [1.基础知识](#1-基础知识)

#### [2.IP协议](#2-ip协议)

#### [3.TCP协议](#3-tcp协议)

#### [4.UDP协议](#4-udp协议)

#### [5.SCTP协议](#5-sctp协议)

#### [6.ARP协议](#6-arp协议)

#### [7.DNS协议](#7-dns协议)

#### [8.参考文献](#参考文献)


---
# 1. 基础知识
[^_^]:
	以下是引用
	[OSI_tcp_five]: https://github.com/CyC2018/CS-Notes/blob/master/pics/426df589-6f97-4622-b74d-4a81fcb1da8e.png
	[osi]: /pics/network/osi7.png
	[tcp_ip]: /pics/network/tcpip.png
	[tcp_ip_protocol]: https://github.com/CyC2018/CS-Notes/raw/master/pics/d4eef1e2-5703-4ca4-82ab-8dda93d6b81f.png


## 1.1 计算机网络体系结构
![OSI_tcp_five]


各层次含义为：

![osi]

- TCP/IP 协议层的主要协议

![tcp_ip_protocol]

![tcp_ip]


---

## 1.2 物理层

通信方式：

- 单工通信：单向传输
- 半双工通信：双向交替传输
- 全双工通信：双向同时传输

---

## 1.3 数据链路层
[^_^]:
	以下是引用
	[frame]: /pics/network/frame.png
	[pppframe]: /pics/network/pppframe.png
	[macFrame]: /pics/network/macframe.png
	
- 实现网卡接口的网络驱动程序，处理数据在物理媒介上的传输。
- 两个常用的协议：
	- ARP(Address Resolve Protocol): 地址解析协议
	- RARP(Reverse Address Resolve Protocol): 逆地址解析协议
	- 主要实现IP地址和及机器物理地址（MAC地址）之间的转换
	
---

#### 信道
1. 点对点信道，一对一的通信方式 
2. 广播信道，一对多的广播通信方式

- 通常使用的多是点对点的信道
	- HDLC协议： 面向比特流的
	- PPP协议： 面向字节流的
	- HDLC在控制字段中提供了可靠的确认机制，因此它可以实现可靠传输，而PPP则不提供可靠传输
	- 全世界使用得最多的数据链路层协议是PPP协议

---

#### 帧

![frame]

#### 以太网帧

以太网帧格式：
- 类型 ：标记上层使用的协议；
- 数据 ：长度在46-1500 之间，如果太小则需要填充；
- FCS ：帧检验序列，使用的是 CRC 检验方法；
- 前同步码 ：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。

![macFrame]

- 帧部：18 字节
- MTU:46-1500 字节；
- 总长：64 ~1518 字节

#### ppp 帧

PPP 的帧格式：
- F 字段为帧的定界符
- A 和 C 字段暂时没有意义
- FCS 字段是使用 CRC 的检验序列
- 信息部分的长度不超过 1500


![pppframe]



- ppp属于广域网范畴，MAC是局域网范畴;
- 按实际情况和环境就选用不同的协议，ppp支持的网络结构只能是点对点，mac支持多点对多点。
- 以太网中用mac，远程的话就用ppp（如ADSL拨号，就是基于ppp的）。


---

#### 信道复用
- 频分复用
频分复用的所有主机在相同的时间占用不同的频率带宽资源。

- 时分复用
时分复用的所有主机在不同的时间占用相同的频率带宽资源。

使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。

- 统计时分复用

是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。

- 波分复用

光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。


- 码分复用

---

#### CSMA/CD 协议
CSMA/CD 表示载波监听多点接入 / 碰撞检测。

- **多点接入** ：说明这是总线型网络，许多主机以多点的方式连接到总线上。
- **载波监听** ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。
- **碰撞检测** ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。
记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为**争用期** 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。

当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 **截断二进制指数退避算法** 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。

![](https://github.com/CyC2018/CS-Notes/raw/master/pics/5aa82b89-f266-44da-887d-18f31f01d8ef.png)


---

## 1.4 网络层

[^_^]:
	以下是引用
	[icmp]: /pics/network/icmp.png


	
- 实现数据包的选路和转发。
- 网络层的主要协议：
	- IP协议
	- ICMP协议（Internet Control Message Protocol, 因特网控制报文协议）
	- IGMP协议（Internet Group Management Protocol, 网际组管理协议）

### ICMP协议

- 格式

![icmp]


- 分类
	- ICMP差错报告报文
	- ICMP询问报文
	
![](https://github.com/CyC2018/CS-Notes/raw/master/pics/aa29cc88-7256-4399-8c7f-3cf4a6489559.png)


---

### IP地址编码

**三个历史阶段**：
- 分类
- 子网划分
- 无分类


#### 1. 分类
由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。
`IP 地址 ::= {< 网络号 >, < 主机号 >}`

![](https://github.com/CyC2018/CS-Notes/raw/master/pics/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png)

#### 2. 子网划分

通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。

`IP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}`

要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。

注意，外部网络看不到子网的存在。

#### 3. 无分类

无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

`IP 地址 ::= {< 网络前缀号 >, < 主机号 >}`

CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。

CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。

一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为**构成超网** 。

在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。



---

## 1.5 传输层


- 传送层提供端到端的通信，传输层只关注起始端和目的端，而不在乎数据包的中转过程。
- 传输层的主要协议：
	- TCP协议：提供**可靠**的，**面向连接**的和**基于流**的服务。
	- UDP协议：提供**不可靠的**，**无连接**的和**基于数据报**的服务。
	- SCTP协议
	

---

## 1.6 应用层

[^_^]:
	以下是引用
	[pic_frame_encap]: /pics/network/frame_encap.png
	[pic_macframe_encap]: /pics/network/macframe_encap.jpg
	[pic_frame_demulti]: /pics/network/frame_demulti.png




- 应用层负责处理应用程序的逻辑，在用户空间实现。
- 数据链路层，网络层和传输层负责处理网络通信细节，在内核空间实现；

- 应用层的协议有很多：
	- ping:应用程序，不是协议，利用ICMP报文检测**网络连接**， 是调试网络环境的工具。
	- telnet:远程登录协议。
	- OSPF(Open Shortest Path First, 开放最短路径优先）：协议是一种动态路由更新协议，用于路由器之间的通信。
	- DNS(Domain Name Service ，域名服务)：协议提供机器域名和IP地址的转换。
	
- 应用程序可以跳过传送层直接使用网络层的服务，如ping 程序 和 OSPF协议。
- 应用程序（或者协议）既可以使用TCP服务，也可以使用UDP服务，如DNS协议。
	

---

#### 封装

![pic_frame_encap]

帧的最大传输单元（MTU）通常受到网络类型的影响。过长的IP数据报被分片(fragment)传输。

![pic_macframe_encap]


---

#### 分用(demultiplexing)
- 帧到达主机，沿着协议栈自底向上依次传递，各层协议处理帧的相关头部信息，获取所需要的信息，最终将处理后的帧交给目标程序，这个过程称为分用。
- 分用是靠头部信息中的类型字段实现的。

![pic_frame_demulti]

- IP,ARP,RARP协议都是使用帧传递数据，帧含有**两字节的类型**来区分协议：
	- IP: 0x800
	- ARP:0x806
	- RARP:0x835
	
- TCP , UDP 协议使用端口号来区分上层应用程序。


---

# 2. IP协议

[^_^]:
	以下是引用
	[pic_ipv4]: /pics/network/ipv4.png
	
	
#### 2.1 特点
- **无状态**、**无连接**、 **不可靠**的服务。
- **无状态**：
	- IP通信对方不同步传输数据的状态信息，所有IP数据报的发送，传输和接收都是独立，没有上下文关系的。
	- 缺点：无法处理乱序和重复的IP数据报。
	- 优点： 高效，简单。
	
- **无连接**：
	- 指的是IP通信双方都不长久地维持对方的任何信息。
	- 每次发送都必须指定目的地址。
	
- **不可靠**：
	- IP协议不能保证IP数据报准确到达接收端，，只是承诺最大努力。

---

#### 2.2 IPv4头部结构

- 长度通常为20字节，除非包含可变长的选项部分。

![pic_ipv4]

1. 4位版本号： 
	- IPv4: 值为4
2. 4位头部长度：（4位最大1111，表示15）IP长度最长60字节
3. 8位服务类型(Type Of Service ,TOS)： 包含一个3位的优先权字段(已被忽略)，4位的TOS字段和1位保留字段(必须置0)
	- 最小延时
	- 最大吞吐量
	- 最高可靠性
	- 最小费用（这几个四位TOS字段中，最多只有一个能置为0）
4. 16位总长度：IP数据报的长度，最大长度为：65535（2^16 -1）字节。
5. 16位标识： 唯一地标识主机发送的每一个数据报，初始值系统随机生成，每发送一个，其值加1。数据报分片时，同一数据报的分片标识一样。
6. 3位标志：
	- 第一位保留
	- 第二位(Don't Fragment,DF): 禁止分片，如果长度超过MTU，IP模块丢弃这个数据报返回一个ICMP差错报文。
	- 第三为(More Fragment, MF): 更多分片，除了数据报最后一个分片，其他分片都要置1.

7. 13位片偏移： 分片相对原始数据报（仅指数据部分）开始处的偏移。
8. 8位生存时间(Time to Live, TTL): 数据报达到目的地之前允许经过的路由器跳数。（常见的值为64）
9. 8位协议：用来区分上层协议
	- ICMP : 1
	- TCP: 6
	- UDP: 17
10. 16位头部校验和： 发送端填充，接收端使用CRC算法检验(**仅校验头部**);
11. 最后两个字段使用表示发送端和目的端的IP地址。

12. 最后一个选项字段是可变长的可选信息，最多40字节


---

#### IP 分片

![](https://github.com/CyC2018/CS-Notes/blob/master/pics/23ba890e-e11c-45e2-a20c-64d217f83430.png)


---

# 3. TCP协议

[^_^]:	
	TCP引用
	[pic_tcp_service]: /pics/network/tcp_bytes.png
	[pic_tcp_header]: /pics/network/tcp_header.png
	[pic_tcp_header_options]: /pics/network/tcp_header_option.png
	[pic_tcp_seven_options]: /pics/network/tcp_seven_option.png
	[pic_tcp_build]: https://github.com/CyC2018/CS-Notes/raw/master/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png
	[pic_tcp_close]: https://github.com/CyC2018/CS-Notes/raw/master/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg
	[pic_tcp_half_close]: /pics/network/tcp_half_close.png	
	[pic_tcp_state]: /pics/network/tcp_state.png
	[pic_tcp_exception]: /pics/network/tcp_exception.png
	[pic_tcp_rtt_rto]: /pics/network/tcp_rtt_rto.png
	[pic_tcp_timeout_resend]: /pics/network/tcp_resend_timeout.png
	[pic_tcp_window]: /pics/network/tcp_window.png
	[pic_tcp_slow_start]: /pics/network/tcp_slow_start.png
	[pic_tcp_fast_repeat]: /pics/network/tcp_fast_repeat.png
	[pic_tcp_network_control]: /pics/network/tcp_network_control.png
	
	
## 3.1 特点
- 面向连接
- 字节流： 应用程序对数据的发送和接收是没有**边界限制**的。
- 可靠传输

TCP的连接是一对一的。

![pic_tcp_service]

---

## 3.2 TCP头部结构

![pic_tcp_header]


1. **两个16位端口号字段**：判断上层协议或者应用程序，客户端是临时端口号，服务端是知名服务器端口号。(/etc/services中定义端口号)
2. **32位序列号**： 一次TCP通信(建立到断开)中某个传输方向上的报文段的编号。如第一个报文段的序号为ISN(Initial Sequence Number，初始序号值)，后续的序号为ISN加上字节流的偏移，例如，某个报文段传送字节流的第1025~2048个字节，那么序号为ISN+1025。
3. **32位确认号**： 对另一方发送的tcp报文段的响应，值为收到的TCP报文段的序号加1.
4. **4位头部长度**： 标志TCP头部的长度，tcp头部最长60字节。
5. **6位保留**
6. **6位标志位**：
	- `URG`: 表示紧急指针是否有效；
	- `ACK`: 表示确认号是否有效，称携带ACK标志的报文段为**确认报文段**；
	- `PSH`：表示接收端应该立即从TCP缓冲区接收缓冲区数据，为后续腾出空间；
	- `RST`: 表示要求对方重建建立连接，携带RST标志的报文段为**复位报文段**；
	- `SYN`: 表示请求建立一个连接，携带SYN标志的报文段为**同步报文段**；
	- `FIN`: 表示通知对方 要关闭连接， 携带FIN标志的报文段为**结束报文段**。
	
7. **16位窗口大小**： 指的是接收通告窗口（RWND），告诉对方本端的TCP接收缓冲区还能容纳多少数据，这样对方能够控制发送数据的速度；
8. **16位校验和**： 发送端填充， 接收端对TCP报文段执行CRC算法来校验（包括头部和数据部分）
9. **16位紧急指针**： 是一个正的偏移量。它和序号相加表示最后一个紧急数据的下一字节的序号。

10. **头部选项**： 最多40字节；


![pic_tcp_header_options]

- kind: 说明选项的类型
- length(可无)： 指定整个选项结构的长度，占一个字节；
- info(可无): 选项的具体信息；

一共有其中TCP选项，简单如下：

![pic_tcp_seven_options]


---

## 3.3 TCP建立

![pic_tcp_build]

### (1)TCP三次握手：

1. 客户端发送 **SYN** 给服务器，说明客户端请求建立连接；
2. 服务端收到客户端发的 **SYN**，并回复 **SYN+ACK** 给客户端（同意建立连接）；
3. 客户端收到服务端的 **SYN+ACK** 后，回复 **ACK** 给服务端（表示客户端收到了服务端发的同意报文）；
4. 服务端收到客户端的 **ACK**，连接已建立，可以数据传输。

---

### (2)TCP为什么要三次握手？

【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）

【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。

【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。


---

### (3)SYN攻击

#### 什么是 SYN 攻击（SYN Flood）？
- 在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.

- SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

- SYN 攻击是一种典型的 DoS/DDoS 攻击。

#### 如何检测 SYN 攻击？

- 检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

#### 如何防御 SYN 攻击？

SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

---

### (4)ddos

#### DDos 攻击

- 客户端向服务端发送请求链接数据包
- 服务端向客户端发送确认数据包
- 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

#### DDos 预防 ( 没有彻底根治的办法，除非不使用TCP )

- 限制同时打开SYN半链接的数目
- 缩短SYN半链接的Time out 时间
- 关闭不必要的服务

---

### (5)TCP KeepAlive
- TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。
- TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。
- 交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪

解决办法：**传输层可以利用 TCP 的 KeepAlive 机制实现来实现**

#### TCP KeepAlive 的基本原理
- 隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

#### 局限
- 首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量
- TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用，例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。
- 因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。


---

## 3.4 TCP关闭

![pic_tcp_close]

---

### (1)TCP四次挥手

1. 客户端发送 **FIN** 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；

2. 服务器接收到客户端发的 **FIN**，并回复 **ACK** 给客户端（同意释放从客户端到服务器的连接）；

3. 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；

4. 服务端继续发送之前**没发完的数据**给客户端；

5. 服务端发送 **FIN+ACK** 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；

6. 客户端收到服务端的 **FIN+ACK**，并回复 **ACK** 给客户端（同意释放从服务端到客户端的连接）；

7. 服务端收到客户端的 **ACK** 后，释放从服务端到客户端的连接。

---

### (2)TCP 为什么要进行四次挥手？

【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？

【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）

【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。

【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？

【答案三】
1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。

2. 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

---

### (3)TCP连接状态？

1. `CLOSED`：初始状态。

2. `LISTEN`：服务器处于监听状态。

3. `SYN_SEND`：客户端socket执行CONNECT连接，发送SYN包，进入此状态。

4. `SYN_RECV`：服务端收到SYN包并发送服务端SYN包，进入此状态。

5. `ESTABLISH`：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。

6. `FIN_WAIT_1`：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。

7. `CLOSE_WAIT`：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。

8. `FIN_WAIT_2`：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。

9. `LAST_ACK`：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。

10 `TIME_WAIT`：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。


---

### (4)解释FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？

**FIN_WAIT_2：**

- 半关闭状态。

- 发送断开请求一方还有接收数据能力，但已经没有发送数据能力。

**CLOSE_WAIT状态：**

- 被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。

- 被动关闭连接一方如果还有剩余数据要发送就会进入CLOSED_WAIT状态。

**TIME_WAIT状态：**

- 又叫2MSL等待状态。
— 如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。
- 在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）

---

## 3.5 半关闭状态

![pic_tcp_half_close]

- 如图，客户端发送FIN标志，现在不能发送数据，但是能够接收数据，这种状态称为半关闭；
- 服务端和客户端判断对方关闭的方法： **read 系统调用返回0（收到结束报文段）**
- FIN_WAIT_2 : 半关闭状态

---

## 3.6 TCP状态转移图

![pic_tcp_state]

---

## 3.7 TCP超时重传

TCP的发送有以下几种结果：

![pic_tcp_exception]

超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：
- 发送的数据没能到达接收端，所以对方没有响应。
- 接收端接收到数据，但是ACK报文在返回过程中丢失。
- 接收端拒绝或丢弃数据。

**重传自适应算法**

![pic_tcp_rtt_rto]

- TCP根据RTT来自适应修改 RTO:
- RTO : 重传超时时间
- RTT: 连接往返时间

重传RTO计算分为两种情况：
1. **未发生超时重传的情况** 

![pic_tcp_timeout_resend]

2. **发生超时重传的情况**

> 新的重传时间 =  2 * （旧的重传时间）

对于一般的情况，比如重传的时间RTO为1s, 2s, 4s,8s,....直到最大时间


---

## 3.8 TCP滑动窗口

**作用**：
- 提供tcp的可靠性
- 提供tcp的流控制特性
- tcp头部窗口大小为16位： TCP标准窗口的最大为：`2^16 - 1 = 65535`个字节；
- 在TCP的选择字段中：包含一个TCP窗口扩大因子，`option-kind = 3`,`option-length = 3`,`option-data`的取值为0~14，可以将原来16bit的窗口扩大到32bit;

![pic_tcp_window]

**发送数据分类：**
1. 已经发送并且得到对端的ACK
2. 已经发送但是未收到对端的ACK
3. 未发送但对端允许发送
4. 未发送且对端不允许发送

其中 2和3 被称为 发送窗口。

**接收数据分类：**
1. 已经接收
2. 未接收准备接收
3. 未接收并未准备接收

其中，2这个部分被称为接收窗口。

---

## 3.9 TCP流量控制

**目的**:

- 是接收方通过**TCP头窗口字段**告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。

- TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。
	- 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。
	
	- 接收窗：用来标记可以接收的数据大小。

---

## 3.10 TCP拥塞控制

- 提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性，这就是拥塞控制。
- 包含四部分：
	- 慢启动(slow start)
	- 拥塞避免(congestion avoidance)
	- 快速重传(fast retransmit)
	- 快速恢复(fast recovery)

---
	
### (1)拥塞窗口

- 发送端引入一个称为拥塞窗口(CWND)的状态变量
- 发送窗口（SWND）的值取决于对端的接收窗口（RWND）和拥塞窗口(CWND)的较小者
	
---
	
### (2)慢启动和拥塞避免

**慢开始原理**
1. 当主机开始发送数据的时候，从小到大逐渐增大发送端的拥塞控制窗口数值，避免引起网络拥塞；
2. 在刚刚开始发送报文段时可以将拥塞窗口cwnd设置为一个最大报文段的MSS（最大段的大小）的数值，每收到一个报文段确认，拥塞窗口增加一个MSS的数值，当对端的接收窗口足够大的时候，为了防止拥塞窗口的增加引起网络拥塞，需要另一个变量，慢开始门限`ssthresh`

**拥塞控制过程**
1. TCP连接初始化，拥塞窗口设置为1
2. 执行慢开始算法，拥塞窗口按指数规律增长，直到拥塞窗口大小 CWND = ssthresh 时候，开始执行拥塞避免算法，拥塞窗口安装线性规律增长；
3. 当网络发生拥塞，把 ssthresh 值更新为拥塞前 ssthresh 的一半，拥塞窗口重新设置为1，按步骤2执行。

![pic_tcp_slow_start]


**判断拥塞发生的情况**
1. 传输超时，或者TCP重传定时器溢出；
2. 接收到重复的确认报文段；

对于上面两种情况：
1. 第一种情况：采用慢启动和拥塞避免
2. 第二种情况： 采用快速重传和快速恢复（如果这种情况发生在定时器溢出后，则当做第一种情况处理）


---

### (3)快重传和快恢复

- 快重传： 要求接收方在收到一个失序的报文段后发出重复确认（使发送方早知道有报文段未到达） 
- 规定： 发送方一连收到三个重复确认即立即重传对方尚未收到的报文段；而不必等到重传计时到期；
	
	
![pic_tcp_fast_repeat]


**要点**
1. 当发送方发送三个连续的重复确认，就执行“乘法减小”算法，将门限 ssthresh 减半，但是接下来不执行慢开始算法；
2. 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所有发送方认为没有出现拥塞，所以不执行慢开始算法，而是将CWND设为 ssthresh的大小，然后执行拥塞避免算法；

![pic_tcp_network_control]


---

# 4. UDP协议

[^_^]:
	UDP引用
	[pic_udp]: https://github.com/CyC2018/CS-Notes/blob/master/pics/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg
	[pic_udp_service]: /pics/network/udp_service.png
		
## 4.1 简介
UDP（用户数据报协议）：是OSI参考模型中的一种**无连接**、**不可靠**、**基于数据报**的传输层协议。

![pic_udp_service]

#### 特点 
1. udp是无连接的 即发送数据报无需建立连接，并因此减少了开销和发送数据之前不必要的时延； 
2. 使用尽量大努力交付；
3. 是面向报文的 

## 4.2 结构

UDP有两个字段：数据字段和首部字段。

![pic_udp]

1. 源端口和目的端口
2. 长度： UPD的长度，最小值为8 ，即首部长度，无数据
3. 检验和： 检验UDP数据报传输是否有错

#### 注意

1. UDP首部中校验和的计算方法有些特殊。在计算校验和时，要在UDP用户数据报之前增加12个字节的伪首部。
2. 伪首部既不向下传送也不向上递交，而仅仅是为了计算校验和。
3. 与IP数据报的校验和只校验IP数据报的首部不同，UDP的校验和是把首部和数据部分一起都校验。


## 4.3 TCP和UDP的区别

TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：

1. TCP是面向连接的，UDP是无连接的；

2. TCP是可靠的，UDP是不可靠的；

3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；

4. TCP是面向字节流的，UDP是面向报文的；

5. TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；

6. TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；


## 4.4 UDP常对应协议

1. DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是**53号**端口。

2. SNMP：简单网络管理协议，使用**161号**端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

3. TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口**69**上使用UDP服务。

---

# 5. SCTP协议

[^_^]:
	SCTP引用
	[pic_multi_homing]: /pics/network/multi_homing.gif
	[pic_multi_stream]: /pics/network/multi_stream.gif
	[pic_init_protect]: /pics/network/init_protect.gif
	[pic_message_framing]: /pics/network/message_framing.gif
	[pic_graceful_close]: /pics/network/graceful_close.gif
	

- 流控制传输协议SCTP（STREAM CONTROL TRANSMISSION PROTOCOL）
- 它为了一些预期的因特网服务而设计的，它结合了UDP TCP 的优点，像UDP一样适合于音频和视频的实时传输，又像TCP一样提供差错控制和流量控制。 

## 5.1 特性

- 多宿主（Multi-Homing）
- 多流（Multi-streaming）
- 初始化保护（Initiation protection）
- 消息分帧（Message framing）
- 可配置的无序发送（Configurable unordered delivery）
- 平滑关闭（Graceful shutdown）

### (1)多宿主（Multi-Homing）
SCTP里面引入了联合（Association）的概念

![pic_multi_homing]

- TCP连接是在两个主机的单个接口之间建立的
- SCTP可以把多条路径合并到一个联合中，数据可以在任意一个连接路径上进行传输

### (3)多流（Multi-streaming）
SCTP可以在一个联合中支持多流机制，每个流（stream）都是独立的。

![pic_multi_stream]


- 每个流都有各自的编号，编码在SCTP报文中
- 阻塞的流不会影响同一联合中的其他流，可以并行进行传输

### (4)初始化保护（Initiation Protection)

TCP中的三次握手机制会被利用来进行DoS（Denial of Service）攻击，通过发送大量的SYN报文最终耗尽服务器的资源

![pic_init_protect]


SCTP通过引入4次握手机制来避免这种场景：
- 服务器的INIT-ACK中会包含cookie（标识这个连接的唯一上下文）；
- 客户端使用这个cookie来进行响应。服务器收到这个响应后，才为这个连接分配资源；
- 为了解决4次握手机制带来的时延，SCTP协议还允许在COOKIE-ECHO和COOKIE-ACK报文中传输数据包


### (5)消息分帧

- TCP协议是按照字节流的方式进行数据传输的，并不存在消息边界，比如说音频视频都可以通过流的方式进行传递；
- UDP使用的是消息分帧，发端多大的数据包，收端收到的数据包也是这么大；

![pic_message_framing]

SCTP也提供了这种分帧的机制

### (6)可配置的无序发送

- TCP能确保数据按照次序发送；UDP无法保证消息有序；SCTP中也可以配置成接受无序的消息；
- 这样的通信方式对于面向消息的传输非常有用，因为每个消息都是各自独立的，次序并不重要。

### (7) 平滑关闭

- TCP和SCTP都是基于连接的协议，完成传输后都需要有一个拆除连接的过程。
- TCP中连接的删除是半关闭的，服务的某一端可以关闭自己这端的socket，但是可以继续接受数据。

![pic_graceful_close]


SCTP协议设计的时候考虑这种半关闭的状态实际上很少使用，所以简化了关闭的过程，一旦某一端发起了连接拆除，对等的两端都关闭。


## 5.2  TCP,UDP,SCTP 使用场合

- [UDP，TCP，SCTP使用场合](https://blog.csdn.net/songshiMVP1/article/details/51893273)

---

# 6. ARP协议

[^_^]:
	以下是引用
	[pic_arp]: /pics/network/arp.png
	
ARP协议实现 任意网络层地址到任意物理地址的转换
工作原理：
- 主机向自己的网络广播一个ARP请求，该请求包含目标机器的网络地址。
- 此网络上的其他机器收到这个请求， 但只有被请求的机器才会回应一个ARP应答，其中包含自己的物理地址。
	
---

#### ARP的格式

![pic_arp]

1. 硬件类型： 定义物理地址类型，值为1表示MAC地址
2. 协议类型： 表示映射的协议地址类型， 它的值为0x800,表示IP地址。
3. 硬件地址长度和协议地址长度： 单位是字节。
	- 对mac地址来说：6
	- 对IP(v4)地址来说：4
4. 操作： 
	- ARP请求(值为1)
	- ARP应答(值为2)
	- RARP请求(值为3)
	- RARP应答(值为4)
5. 最后四个字段指定双方的以太网地址和IP地址。

从上面看出，ARP的长度为**28字节**。
	
	
---
# 7. DNS协议

[^_^]:
	以下是引用
	[pic_dns]: /pics/network/dns.png


#### dns 查询和应答报文

![pic_dns]

- 16位标识字段用于标记一对DNS查询和应答，以此1区分一个DNS应答是哪个DNS查询的回应。
- 16位标志字段用于协商具体的通信方式和反馈通信状态。
- 接下来四个字段指出DNS报文的资源记录数目。
	- 查询报文：包含一个查询问题，应答资源记录数、授权资源记录数、额外的资源记录数则为0
	- 应答报文：应答资源记录数至少为1，授权资源记录和额外资源记录可为0 或非0
	
	


# 参考文献

1. [数据链路层详解]: https://blog.csdn.net/xiongqiaochu/article/details/65653132

2. [数据链路层]: https://blog.csdn.net/xiongqiaochu/article/details/65653132

3. [icmp详解]: https://blog.csdn.net/jxch____/article/details/78876995

4. [笔试面试知识整理](https://hit-alibaba.github.io/interview/basic/network/TCP.html)

5. [SCTP通信协议简介](https://www.jianshu.com/p/08cba3d3eb9f)

6. [小土刀的面试刷题笔记](https://wdxtub.com/interview/14520846750052.html)

7. [UDP，TCP，SCTP使用场合](https://blog.csdn.net/songshiMVP1/article/details/51893273)

8. [面试/笔试第一弹 —— 计算机网络面试问题集锦](https://blog.csdn.net/justloveyou_/article/details/78303617)