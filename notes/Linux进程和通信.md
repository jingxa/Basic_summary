## 




# 一、进程

## 1. 孤儿进程
- 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。



---

## 2. 僵尸进程

- 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

- 僵尸进程还会消耗一定的系统资源，并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息。一旦父进程得到想要的信息，僵尸进程就会结束。


### 清除僵尸进程
1. 杀掉父进程：父进程死后，僵尸进程成为"孤儿进程"，过继给1号进程init，init始终会负责清理僵尸进程。它产生的所有僵尸进程也跟着消失。
2. 接管SIGCHLD信号。子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行wait()或者waitpid()函数为子进程收尸


```c++

#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);


status是一个传出参数。
waitpid的pid参数选择：
< -1 回收指定进程组内的任意子进程
= -1 回收任意子进程
= 0  回收和当前调用waitpid一个组的所有子进程
> 0  回收指定ID的子进程

```

#### 查看僵尸教程

- `ps aux`



---

## 3. 守护进程

- 守护进程就是在后台运行，不与任何终端关联的进程，通常情况下守护进程在系统启动时就在运行，它们以root用户或者其他特殊用户(apache和postfix)运行，并能处理一些系统级的任务。习惯上守护进程的名字通常以d结尾(sshd)，但这些不是必须的

- 守护进程是脱离于终端并且在后台运行的进程。守护进程脱离于终端，是为了避免进程在执行过程中的信息在任何终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。
- 守护进程，也就是通常说的Daemon进程，是Linux中的后台服务进程.


### 创建步骤

#### 1. 后台运行

为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。

```c++
if(pid=fork())
exit(0); //是父进程，结束父进程，子进程继续

```

#### 2. 脱离控制终端，登录会话和进程组

- 有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长：

```c++
setsid();
```

说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。


#### 3. 禁止进程重新打开控制终端

进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端：


```c++
if(pid=fork()) exit(0); //结束第一子进程，第二子进程继续（第二子进程不再是会话组长）

```

#### 4. 关闭打开的文件描述符

进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按如下方法关闭它们：

```c++
for(int i = 0; i < 65535; ++i){close(i);}
```

#### 5. 改变当前工作目录

进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 /tmpchdir("/")

```c++
chdir("/");
```

#### 6. 重设文件创建掩模

进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：

```c++
umask(0);
```

#### 7. 处理SIGCHLD信号（非必须）

处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将 SIGCHLD信号的操作设为SIG_IGN。

```c++

signal(SIGCHLD,SIG_IGN);
```

#### 8. 重定向标准输入输出
 
某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出和标准出错的库例程都不会产生任何效果


- 【参考资料】[如何实现守护进程？](https://blog.csdn.net/qq_26499321/article/details/72724173)







