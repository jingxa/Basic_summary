## 




# 一、进程

## 1. 孤儿进程
- 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。



---

## 2. 僵尸进程

- 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

- 僵尸进程还会消耗一定的系统资源，并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息。一旦父进程得到想要的信息，僵尸进程就会结束。


### 清除僵尸进程
1. 杀掉父进程：父进程死后，僵尸进程成为"孤儿进程"，过继给1号进程init，init始终会负责清理僵尸进程。它产生的所有僵尸进程也跟着消失。
2. 接管SIGCHLD信号。子进程死后，会发送SIGCHLD信号给父进程，父进程收到此信号后，执行wait()或者waitpid()函数为子进程收尸


```c++

#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *status, int options);


status是一个传出参数。
waitpid的pid参数选择：
< -1 回收指定进程组内的任意子进程
= -1 回收任意子进程
= 0  回收和当前调用waitpid一个组的所有子进程
> 0  回收指定ID的子进程

```

#### 查看僵尸教程

- `ps aux`



---

## 3. 守护进程

- 守护进程就是在后台运行，不与任何终端关联的进程，通常情况下守护进程在系统启动时就在运行，它们以root用户或者其他特殊用户(apache和postfix)运行，并能处理一些系统级的任务。习惯上守护进程的名字通常以d结尾(sshd)，但这些不是必须的

- 守护进程是脱离于终端并且在后台运行的进程。守护进程脱离于终端，是为了避免进程在执行过程中的信息在任何终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。
- 守护进程，也就是通常说的Daemon进程，是Linux中的后台服务进程.


### 创建步骤

#### 1. 后台运行

为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。

```c++
if(pid=fork())
exit(0); //是父进程，结束父进程，子进程继续

```

#### 2. 脱离控制终端，登录会话和进程组

- 有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长：

```c++
setsid();
```

说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。


#### 3. 禁止进程重新打开控制终端

进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端：


```c++
if(pid=fork()) exit(0); //结束第一子进程，第二子进程继续（第二子进程不再是会话组长）

```

#### 4. 关闭打开的文件描述符

进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按如下方法关闭它们：

```c++
for(int i = 0; i < 65535; ++i){close(i);}
```

#### 5. 改变当前工作目录

进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 /tmpchdir("/")

```c++
chdir("/");
```

#### 6. 重设文件创建掩模

进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：

```c++
umask(0);
```

#### 7. 处理SIGCHLD信号（非必须）

处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将 SIGCHLD信号的操作设为SIG_IGN。

```c++

signal(SIGCHLD,SIG_IGN);
```

#### 8. 重定向标准输入输出
 
某些守护进程打开/dev/null使其具有文件描述符0、1和2，这样，任何一个试图读标准输入、写标准输出和标准出错的库例程都不会产生任何效果


- 【参考资料】[如何实现守护进程？](https://blog.csdn.net/qq_26499321/article/details/72724173)



---

## 4.  Linux 相关的系统调用

### (1). read()

调用 `sys_open:`
- `getname()`:把文件名传送到内核空间
- `get_unused_fd()`: 获得下一个可用的文件描述符
- `filp_open()`: 创建nameidata结构体
- `open_namei()`:初始化nameidata结构体 
- `dentry_open()`: 创建并初始化文件对象
- `fd_install()`: `将current->files->fd[fd]设置成文件对象`
- `putname()`:回收为文件名分配的内核空间


### (2). close()
- `sys_close()`

- `__put_unused_fd()`:吧文件描述符归还给可用池
- `filp_close()`: 准备即将清除的文件对象
- `fput()`: 清除文件对象


### (3).read()
- sys_read()

- 

### (4) write()



---

## 5. Linux 启动过程


![](https://images2015.cnblogs.com/blog/607348/201512/607348-20151229231206354-919070678.png)


1. BIOS
- 计算机在开机时，会最先读取该系统，然后会有一个加电自检过程，这个过程其实就是检查CPU和内存，计算机最基本的组成单元(控制器、运算器和存储器)，还会检查其他硬件，若没有异常就开始加载BIOS程序到内存当中。
- BIOS主要的一个功能就是存储了磁盘的启动顺序，BIOS会按照启动顺序去查找第一个磁盘头的MBR信息，并加载和执行MBR中的Bootloader程序，若第一个磁盘不存在MBR，则会继续查找第二个磁盘(PS：启动顺序可以在BIOS的界面中进行设置)，一旦BootLoader程序被检测并加载内存中，BIOS就将控制权交接给了BootLoader程序。

2. MBR

- MBR(Master Boot Record)，主引导记录，MBR存储于磁盘的头部，大小为512bytes，其中，446bytes用于存储BootLoader程序，64bytes用于存储分区表信息，最后2bytes用于MBR的有效性检查。
 
3. GRUB

GRUB(Grand Unified Bootloader)，多系统启动程序，其执行过程可分为三个步骤：

- Stage1：这个其实就是MBR，它的主要工作就是查找并加载第二段Bootloader程序(stage2)，但系统在没启动时，MBR根本找不到文件系统，也就找不到stage2所存放的位置，因此，就有了stage1_5

- Stage1_5：该步骤就是为了识别文件系统

- Stage2：GRUB程序会根据/boot/grub/grub.conf文件查找Kernel的信息，然后开始加载Kernel程序，当Kernel程序被检测并在加载到内存中，GRUB就将控制权交接给了Kernel程序。

4. Kernel

- Kernel，内核，Kernel是Linux系统最主要的程序，实际上，Kernel的文件很小，只保留了最基本的模块，并以压缩的文件形式存储在硬盘中，当GRUB将Kernel读进内存，内存开始解压缩内核文件。讲内核启动，应该先讲下initrd这个文件，

- initrd(Initial RAM Disk)，它在stage2这个步骤就被拷贝到了内存中，这个文件是在安装系统时产生的，是一个临时的根文件系统(rootfs)。因为Kernel为了精简，只保留了最基本的模块，因此，Kernel上并没有各种硬件的驱动程序，也就无法识rootfs所在的设备，故产生了initrd这个文件，该文件装载了必要的驱动模块，当Kernel启动时，可以从initrd文件中装载驱动模块，直到挂载真正的rootfs，然后将initrd从内存中移除。

- Kernel会以只读方式挂载根文件系统，当根文件系统被挂载后，开始装载第一个进程(用户空间的进程)，执行/sbin/init，之后就将控制权交接给了init程序。





5. Init
- init，初始化，顾名思义，该程序就是进行OS初始化操作，实际上是根据/etc/inittab(定义了系统默认运行级别)设定的动作进行脚本的执行，第一个被执行的脚本为/etc/rc.d/rc.sysinit，这个是真正的OS初始化脚本，简单讲下这个脚本的任务(可以去看看实际脚本，看看都做了什么)：

- 1、激活udev和selinux；
- 2、根据/etc/sysctl.conf文件，来设定内核参数；
- 3、设定系统时钟；
- 4、装载硬盘映射；
- 5、启用交换分区；
- 6、设置主机名；
- 7、根文件系统检测，并以读写方式重新挂载根文件系统；
- 8、激活RAID和LVM设备；
- 9、启用磁盘配额；
- 0、根据/etc/fstab，检查并挂载其他文件系统；
- 11、清理过期的锁和PID文件

- 执行完后，根据配置的启动级别，执行对应目录底下的脚本，最后执行/etc/rc.d/rc.local这个脚本，至此，系统启动完成。




6. Runlevel

runlevel，运行级别，不同的级别会启动的服务不一样，init会根据定义的级别去执行相应目录下的脚本，Linux的启动级别分为以下几种

- 0：关机模式

- 1：单一用户模式(直接以管理员身份进入)

- 2：多用户模式（无网络）

- 3：多用户模式（命令行）

- 4：保留

- 5：多用户模式（图形界面）

- 6：重启

 
在不同的运行级别下，/etc/rc.d/rc这个脚本会分别执行不同目录下的脚本

- `Run level 0 – /etc/rc.d/rc0.d/`
- `Run level 1 – /etc/rc.d/rc1.d/`
- `Run level 2 – /etc/rc.d/rc2.d/`
- `Run level 3 – /etc/rc.d/rc3.d/`
- `Run level 4 – /etc/rc.d/rc4.d/`
- `Run level 5 – /etc/rc.d/rc5.d/`
- `Run level 6 – /etc/rc.d/rc6.d/`

这些目录下的脚本只有K*和S*开头的文件，K开头的文件为开机需要执行关闭的服务，S开头的文件为开机需要执行开启的服务。





---

## 6. linux内存管理








