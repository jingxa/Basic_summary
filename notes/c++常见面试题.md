
# 参考文献
- [c++中虚基类表和虚函数表的布局](https://blog.csdn.net/castle_kao/article/details/71024411)



# 常见面试题

## 1. 内存对其
关于内存对齐，先让我们看四个重要的基本概念：
1.数据类型自身的对齐值：
对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。
2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。
3.指定对齐值：#pragma pack(n)，n=1,2,4,8,16改变系统的对齐系数
4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。


## 2. static 和const分别怎么用，类里面static和const可以同时修饰成员函数吗。

### (1) static

#### 变量

1. 局部变量
- 内存中的位置：静态存储区

- 初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）

- 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。

 注：**当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问），但未改变其作用域。**
 
 
2. 全局变量
- 内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）

- 初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）

- 作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。

注：**static修饰全局变量，并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量**

- 不会被其他文件所访问
- 其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用


 
3. 类

用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。**因此，static成员必须在类外进行初始化(初始化格式： int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化 **。

- 不要试图在头文件中定义(初始化)静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef #define #endif或者#pragma once也不行。 
- 静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。

- **静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以**。普通数据成员的只能声明为 所属类类型的指针或引用。


4. 成员函数

- 用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。
- 静态成员是可以独立访问的
- 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。


### (2) const

1. 限定变量为不可修改。

2. 限定成员函数不可以修改任何数据成员。

3. const与指针：

	- const char *p 表示 指向的内容不能改变。

	- char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。



#### 总结

- **不可以同时用const和static修饰成员函数。**
	- C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。

- static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。





## 3. 指针和引用的区别，引用可以用常指针实现吗。
- 引用是直接访问，指针是间接访问
- 引用是变量的别名，不占用内存空间，指针有自己的内存空间
- 引用是绑定内存的，一个引用被赋值之后不能更改绑定，只能改变引用对象的值




## 4. 继承和组合关系下的构造和析构

构造：Base(), Component(), Derived()
析构：~Derived(), ~,Component(),~Base()






## 5. 虚函数表和虚拟继承

注意：对于在对象中存取虚基类的问题，虚基类表仅是Microsoft编译器的解决办法。在其他编译器中，一般采用在虚函数表中放置虚基类的偏移量的方式。

1. 一个对象实例只有一个虚函数表，只有一个虚基类表。 
2. 对象的每个基类都有一个属于自己的虚函数表指针（vfptr）指向虚函数表(vftbl)的某一项，都有一个属于自己的虚基类表指针(vbptr)指向虚基类表(vbtbl)的某一项。 
3. 虚函数表中按照对象继承的顺序排列对象的虚函数地址，虚基类表中按照对象继承的顺序排列对象的直接虚继承类到虚基类的偏移。 
4. 当基类无虚函数，且派生类有独立虚函数时，派生类对象起始位置为自己的虚函数表指针。否则**派生类的虚函数会归到第一个带虚函数表指针的基类的虚函数表指向范围**，这样就节省了一个vfptr的空间。



![虚基类表](https://images2015.cnblogs.com/blog/364303/201608/364303-20160815131033578-1325553756.png)

- 虚基类表每项记录了被继承的**虚基类子对象相对于虚基类表指针的偏移量**
- `-4` ：vbptr为基类的虚基类表指针，位于vfptr的下方（从内存布局角度看是下方，但是地址更高）。对虚基类表的第一项取值得到的就是-4，表示虚基类表指针到基类的偏移量,其他代表到
- 比如MyClassA的虚基类表第二项记录值为24，正是MyClass::vfptr相对于MyClassA::vbptr的偏移量，同理MyClassB的虚基类表第二项记录值12也正是MyClass::vfptr相对于MyClassA::vbptr的偏移量

虚函数表的结尾处是由4字节的0作为结束标记的。





















 
 
 
 
 
 
 
 