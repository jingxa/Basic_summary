
# 参考资料




# 一、 内存管理

## 1. 查看系统内存
1. top
- top命令是用来监控Linux系统状况，比如cpu、内存的使用。

2. vmstat

- vitual memory statistics 的缩写，实时输出系统的各种资源的使用情况，如进程信息，内存使用，cpu使用率以及iO使用情况

3. free


---

## 2. 概念

### 2.1. 虚拟内存

虚拟内存是Linux管理内存的一种技术。它使得每个应用程序都认为自己拥有独立且连续的可用的内存空间（一段连续完整的地址空间），而实际上，它通常是被映射到多个物理内存段，还有部分暂时存储在外部磁盘存储器上，在需要时再加载到内存中来。

- 每个进程所能使用的虚拟地址大小和CPU位数有关，在32位的系统上，虚拟地址空间大小是4G，在64位系统上，是2^64

#### 优点

- 更大的地址空间：并且是连续的，使得程序编写、链接更加简单

- 进程隔离：不同进程的虚拟地址之间没有关系，所以一个进程的操作不会对其它进程造成影响

- 数据保护：每块虚拟内存都有相应的读写属性，这样就能保护程序的代码段不被修改，数据块不能被执行等，增加了系统的安全性

- 内存映射：有了虚拟内存之后，可以直接映射磁盘上的文件（可执行文件或动态库）到虚拟地址空间，这样可以做到物理内存延时分配，只有在需要读相应的文件的时候，才将它真正的从磁盘上加载到内存中来，而在内存吃紧的时候又可以将这部分内存清空掉，提高物理内存利用效率，并且所有这些对应用程序来说是都透明的

- 共享内存：比如动态库，只要在内存中存储一份就可以了，然后将它映射到不同进程的虚拟地址空间中，让进程觉得自己独占了这个文件。进程间的内存共享也可以通过映射同一块物理内存到进程的不同虚拟地址空间来实现共享

- 物理内存管理：物理地址空间全部由操作系统管理，进程无法直接分配和回收，从而系统可以更好的利用内存，平衡进程间对内存的需求

- 其它：有了虚拟地址空间后，交换空间和COW（copy on write）等功能都能很方便的实现


### 2.2. MMU（Memory Management Unit）

- MMU是CPU的一个用来将**进程的虚拟地址**转换成**物理地址**的模块，简单点说，这个模块的输入是进程的page table和虚拟地址，输出是物理地址。将虚拟地址转换成物理地址的速度直接影响着系统的速度，所以CPU包含了这个模块用来加速。


### 2.3. TLB（Translation Lookaside Buffer）

- 转换检测缓冲区

- 上面介绍到，MMU的输入是page table，而page table又存在内存里面，跟CPU的cache相比，内存的速度很慢，所以为了进一步加快虚拟地址到物理地址的转换速度，Linux发明了TLB，它存在于CPU的L1 cache里面，用来缓存已经找到的虚拟地址到物理地址的映射，这样下次转换前先查一下TLB，如果已经在里面了就不需要调用MMU了.


---

## 3. 物理内存 

### 3.1 页

- 页(page)是内核的内存管理基本单位。

```c++

struct page {
       page_flags_t flags;  页标志符
       atomic_t _count;    页引用计数
       atomic_t _mapcount;     页映射计数
       unsigned long private;    私有数据指针
       struct address_space *mapping;    该页所在地址空间描述结构指针，用于内容为文件的页帧
       pgoff_t index;               该页描述结构在地址空间radix树page_tree中的对象索引号即页号
       struct list_head lru;        最近最久未使用struct slab结构指针链表头变量
       void *virtual;               页虚拟地址
};

```


- flags：页标志包含是不是脏的，是否被锁定等等，每一位单独表示一种状态，可同时表示出32种不同状态，定义在<linux/page-flags.h>
- _count：计数值为-1表示未被使用。
- virtual：页在虚拟内存中的地址，对于不能永久映射到内核空间的内存(比如高端内存)，该值为NULL；需要事必须动态映射这些内存。


内核用struct page结构体表示每个物理页，struct page结构体占40个字节，假定系统物理页大小为4KB，对于4GB物理内存，1M个页面，故所有的页面page结构体共占有内存大小为40MB，相对系统4G，这个代价并不高。


### 3.2 区

内核把页划分在不同的区(zone)


| 区 | 描述 | 物理内存(MB)|
| -  |  -   |   -     |
| ZONE_DMA | DMA使用的页 | <16 |
|ZONE_NORMAL | 可正常寻址的页 | 16 ~896 |
|ZONE_HIGHMEM |	动态映射的页 | >896 |


- 执行DMA操作的内存必须从ZONE_DMA区分配
- 一般内存，既可从ZONE_DMA，也可从ZONE_NORMAL分配，但不能同时从两个区分配；



### 3.3 页分配与释放

| 页分配函数| 描述 |
| - | — |
| `alloc_pages(gfp_mask, order)` |	分配2^order个页，返回指向第一页的指针 |
| `alloc_page(gfp_mask)` |	分配一页，返回指向页的指针,对上边函数调用。order为0 |
| `__get_free_pages(gfp_mask, order)` |	分配2^order个页，返回指向其逻辑地址的指针 | 
| `__get_free_page(gfp_mask)` | 分配一页，返回指向其逻辑地址的指针，对上边函数的调用，order为0 |
| `get_zeroed_page(gfp_mask)`  | 	分配一页，并填充内容为0，返回指向其逻辑地址的指针 |


物理地址转换为逻辑地址：

- `void* page_address(struct page *page)`:返回一个指针，指向给定物理页当前所在的逻辑地址


- `get_zeroed_page`：把分配好的页填充为0， 对于用户空间，这个方法能保障系统敏感数据不会泄露


| 页释放函数 | 描述 |
| `__free_pages(page, order)` | 从page开始，释放2^order个页 |
| `free_pages(addr, order)` | 从地址addr开始，释放2^order个页 | 
| `free_page(addr)` | 释放addr所在的那一页 | 




### 3.4 字节分配和释放

kmalloc，vmalloc分配都是以字节为单位

#### (1)  kmalloc

- 该函数返回的是一个指向内存块的指针，其内存块大小至少为size,所分配的内存在物理内存中连续且保持原有的数据(不清零)

```c++

void * kmalloc(size_t size, gfp_t flags);

```

- kmalloc内存分配最终总是调用__get_free_pages 来进行实际的分配，故前缀都是GFP_开头。
- kmalloc分最多只能分配32个page大小的内存，每个page=4k，也就是128K大小，其中16个字节用来记录页描述结构。
- kmalloc分配的是常驻内存，不会被交换到文件中。最小分配单位是32或64字节。

#### (2) kzalloc

kzalloc()等价于先用 kmalloc() 申请空间， 再用memset()来初始化，所有申请的元素都被初始化为0。

```c++

static inline void *kzalloc(size_t size, gfp_t flags)
{
    return kmalloc(size, flags | __GFP_ZERO); //通过或标志位__GFP_ZERO，初始化元素为0
}

```


#### (3) vmalloc

```c++

void * vmalloc(unsigned long size)
```

该函数返回的是一个指向内存块的指针，其内存块大小至少为size,所分配的内存是逻辑上连续的。

kmalloc不同，该函数乜有flags,默认是可以休眠的。




| 分配函数 | 区域 | 连续性 | 大小 | 释放函数 | 优势
| kmalloc | 内核空间 | 物理地址连续 | 最大值128K-16 | kfree	| 性能更佳 |
| vmalloc | 内核空间 | 虚拟地址连续 | 更大 | vfree | 更易分配大内存 | 
| malloc | 用户空间	 | 虚拟地址连续 | 更大 | free | 	 |


---

### 3.5 slab层

slab分配器的作用：

- 对于频繁地分配和释放的数据结构，会缓存它；
- 频繁分配和回收比如导致内存碎片，为了避免，空闲链表的缓存会连续的存放，已释放的数据结构又会放回空闲链表，不会导致碎片；
- 让部分缓存专属单个处理器，分配和释放操作可以不加SMP锁；


slab层把不同的对象划分为高速缓存组，每个高速缓存组都存放不同类型的对象，每个对象类型对应一个高速缓存。kmalloc接口监理在slab层只是，使用一组通用高速缓存。
